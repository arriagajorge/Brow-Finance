# -*- coding: utf-8 -*-
"""gbm_v2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t3AEcqAWXsr_eEzbzK6qN6o1TCWISp4p

## 7 days
"""

# -*- coding: utf-8 -*-
"""AnÃ¡lisis y SimulaciÃ³n de Acciones del S&P 500 con GrÃ¡ficos y Probabilidades.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_v_m5P5e7s_g_z_qC9bC3n9J8XwYtL4K
"""

# ==============================================================================
# 1. InstalaciÃ³n de LibrerÃ­as
# ==============================================================================
!pip install yfinance pandas numpy scipy matplotlib -q

import pandas as pd
import yfinance as yf
import numpy as np
from datetime import datetime, timedelta
from scipy.stats import shapiro
import matplotlib.pyplot as plt
import warnings

# Ignorar advertencias futuras para una salida mÃ¡s limpia
warnings.simplefilter(action='ignore', category=FutureWarning)

# ==============================================================================
# 2. ObtenciÃ³n de Tickers del S&P 500
# ==============================================================================
try:
    # Obtenemos la tabla de Wikipedia con los tickers del S&P 500
    url = 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'
    tabla = pd.read_html(url)
    sp500_tickers = tabla[0]['Symbol'].tolist()
    print(f"âœ… Se obtuvieron {len(sp500_tickers)} tickers del S&P 500.")
except Exception as e:
    print(f"âš ï¸ No se pudo obtener la lista de tickers: {e}")
    # Lista de respaldo en caso de fallo
    sp500_tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'TSLA', 'JPM', 'JNJ', 'V', 'PG']

# ==============================================================================
# 3. Descarga de Datos y Prueba de Normalidad
# ==============================================================================
end_date = datetime.now()
start_date = end_date - timedelta(days=90)
normal_stocks_tickers = []
stock_data = {}

print("\nDescargando datos y filtrando por distribuciÃ³n normal...")
for ticker in sp500_tickers:
    try:
        # Algunos tickers en la lista de Wikipedia pueden ser incorrectos (ej. 'BF.B'),
        # yfinance puede necesitar un ajuste ('BF-B'). yfinance a menudo maneja esto,
        # pero el manejo de excepciones es clave.
        data = yf.download(ticker, start=start_date, end=end_date, progress=False, auto_adjust=True)
        if not data.empty and len(data) > 30:
            data['Log_Returns'] = np.log(data['Close'] / data['Close'].shift(1))
            data.dropna(inplace=True)
            if len(data['Log_Returns']) > 3:
                stat, p_value = shapiro(data['Log_Returns'])
                if p_value > 0.05:
                    normal_stocks_tickers.append(ticker)
                    stock_data[ticker] = data
    except Exception as e:
        pass

print(f"âœ… Se encontraron {len(normal_stocks_tickers)} acciones cuyos rendimientos siguen una distribuciÃ³n normal.")

# ==============================================================================
# 4. SimulaciÃ³n, CÃ¡lculo de Precio Esperado y Probabilidades
# ==============================================================================
num_simulations = 100000
time_horizon = 5  # DÃ­as de trading
results = []

print("\nEjecutando simulaciones de Montecarlo...")

for ticker in normal_stocks_tickers:
    data = stock_data[ticker]
    if data.empty:
        continue

    mu = data['Log_Returns'].mean()
    sigma = data['Log_Returns'].std()
    last_price = data['Close'].iloc[-1]

    # Ejecutamos la simulaciÃ³n
    final_prices = np.zeros(num_simulations)
    for i in range(num_simulations):
        daily_returns = np.exp(mu - 0.5 * sigma**2 + sigma * np.random.normal(0, 1, time_horizon))
        final_price = last_price * np.prod(daily_returns)
        final_prices[i] = final_price

    # Calculamos mÃ©tricas
    expected_price = np.mean(final_prices)
    percentage_change = ((expected_price - last_price) / last_price) * 100

    # Calculamos las probabilidades
    increase_threshold = last_price * 1.01 # Umbral para incremento del 1%
    decrease_threshold = last_price * 0.99 # Umbral para decremento del 1%

    increase_threshold_value = increase_threshold.iloc[0]
    decrease_threshold_value = decrease_threshold.iloc[0]

    prob_increase = np.sum(final_prices >= increase_threshold_value) / num_simulations * 100
    prob_decrease = np.sum(final_prices <= decrease_threshold_value) / num_simulations * 100

    #prob_increase = np.sum(final_prices >= threshold_value) / num_simulations * 100
    #prob_increase = np.sum(final_prices >= increase_threshold)
    #print(prob_increase)
     #/ num_simulations * 100
    #prob_decrease = np.sum(final_prices <= decrease_threshold) / num_simulations * 100

    results.append({
        'Ticker': ticker,
        'Precio Actual (USD)': float(last_price),
        'Precio Esperado (USD)': float(expected_price),
        'Cambio Esperado (%)': float(percentage_change),
        'Prob. > +1%': float(prob_increase),
        'Prob. < -1%': float(prob_decrease)
    })

# ==============================================================================
# 5. Resultados: Tabla General
# ==============================================================================
if results:
    results_df = pd.DataFrame(results)
    sorted_results = results_df.sort_values(by='Cambio Esperado (%)', ascending=False)

    # Formateamos los nÃºmeros para una mejor visualizaciÃ³n
    sorted_results['Precio Actual (USD)'] = sorted_results['Precio Actual (USD)'].map('${:,.2f}'.format)
    sorted_results['Precio Esperado (USD)'] = sorted_results['Precio Esperado (USD)'].map('${:,.2f}'.format)
    sorted_results['Cambio Esperado (%)'] = sorted_results['Cambio Esperado (%)'].map('{:+.2f}%'.format)
    sorted_results['Prob. > +1%'] = sorted_results['Prob. > +1%'].map('{:.2f}%'.format)
    sorted_results['Prob. < -1%'] = sorted_results['Prob. < -1%'].map('{:.2f}%'.format)

    print("\n\nðŸ“ˆ TABLA DE RESULTADOS DE SIMULACIÃ“N (ORDENADA POR CAMBIO ESPERADO) ðŸ“ˆ\n")
    pd.set_option('display.max_rows', None)
    print(sorted_results.to_string(index=False))
else:
    print("\nNo se encontraron acciones que pasaran la prueba de normalidad.")


# ==============================================================================
# 6. Resultados: GrÃ¡ficos y Detalles Individuales
# ==============================================================================
if results:
    print("\n\nðŸ“Š ANÃLISIS GRÃFICO INDIVIDUAL ðŸ“Š\n")
    plt.style.use('seaborn-v0_8-darkgrid')

    # Usamos el dataframe sin formatear para los cÃ¡lculos de los grÃ¡ficos
    for index, row in results_df.iterrows():
        ticker = row['Ticker']
        data = stock_data[ticker]
        last_price = row['Precio Actual (USD)']
        expected_price = row['Precio Esperado (USD)']

        print(f"--- AnÃ¡lisis para {ticker} ---")
        print(f"Precio Actual: ${last_price:,.2f}")
        print(f"Precio Esperado en 1 Mes: ${expected_price:,.2f}")
        print(f"Cambio Esperado: {row['Cambio Esperado (%)']:+.2f}%")
        print(f"Probabilidad de un aumento > 1%: {row['Prob. > +1%']:.2f}%")
        print(f"Probabilidad de una disminuciÃ³n > 1%: {row['Prob. < -1%']:.2f}%\n")

        # VisualizaciÃ³n con una simulaciÃ³n mÃ¡s pequeÃ±a
        plt.figure(figsize=(10, 6))
        simulation_matrix = np.zeros((time_horizon + 1, 100)) # Matriz para 100 trayectorias
        simulation_matrix[0, :] = last_price

        mu = data['Log_Returns'].mean()
        sigma = data['Log_Returns'].std()

        for i in range(100):
            price_path = np.zeros(time_horizon + 1)
            price_path[0] = last_price
            for t in range(1, time_horizon + 1):
                daily_return = np.exp(mu - 0.5 * sigma**2 + sigma * np.random.normal(0, 1))
                price_path[t] = price_path[t-1] * daily_return
            simulation_matrix[:, i] = price_path

        plt.plot(simulation_matrix, color='gray', alpha=0.1)
        plt.plot(simulation_matrix.mean(axis=1), color='dodgerblue', linewidth=2, label='Trayectoria Promedio')
        plt.axhline(y=expected_price, color='red', linestyle='--', label=f'Precio Esperado Final: ${expected_price:.2f}')
        plt.title(f'SimulaciÃ³n de Precio para {ticker} (1 Mes)')
        plt.xlabel('DÃ­as de Trading Futuros')
        plt.ylabel('Precio de la AcciÃ³n (USD)')
        plt.legend()
        plt.show()
        print("\n" + "="*50 + "\n")

"""## 14 days"""

# -*- coding: utf-8 -*-
"""AnÃ¡lisis y SimulaciÃ³n de Acciones del S&P 500 con GrÃ¡ficos y Probabilidades.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_v_m5P5e7s_g_z_qC9bC3n9J8XwYtL4K
"""

# ==============================================================================
# 1. InstalaciÃ³n de LibrerÃ­as
# ==============================================================================
!pip install yfinance pandas numpy scipy matplotlib -q

import pandas as pd
import yfinance as yf
import numpy as np
from datetime import datetime, timedelta
from scipy.stats import shapiro
import matplotlib.pyplot as plt
import warnings

# Ignorar advertencias futuras para una salida mÃ¡s limpia
warnings.simplefilter(action='ignore', category=FutureWarning)

# ==============================================================================
# 2. ObtenciÃ³n de Tickers del S&P 500
# ==============================================================================
try:
    # Obtenemos la tabla de Wikipedia con los tickers del S&P 500
    url = 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'
    tabla = pd.read_html(url)
    sp500_tickers = tabla[0]['Symbol'].tolist()
    print(f"âœ… Se obtuvieron {len(sp500_tickers)} tickers del S&P 500.")
except Exception as e:
    print(f"âš ï¸ No se pudo obtener la lista de tickers: {e}")
    # Lista de respaldo en caso de fallo
    sp500_tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'TSLA', 'JPM', 'JNJ', 'V', 'PG']

# ==============================================================================
# 3. Descarga de Datos y Prueba de Normalidad
# ==============================================================================
end_date = datetime.now()
start_date = end_date - timedelta(days=180)
normal_stocks_tickers = []
stock_data = {}

print("\nDescargando datos y filtrando por distribuciÃ³n normal...")
for ticker in sp500_tickers:
    try:
        # Algunos tickers en la lista de Wikipedia pueden ser incorrectos (ej. 'BF.B'),
        # yfinance puede necesitar un ajuste ('BF-B'). yfinance a menudo maneja esto,
        # pero el manejo de excepciones es clave.
        data = yf.download(ticker, start=start_date, end=end_date, progress=False, auto_adjust=True)
        if not data.empty and len(data) > 30:
            data['Log_Returns'] = np.log(data['Close'] / data['Close'].shift(1))
            data.dropna(inplace=True)
            if len(data['Log_Returns']) > 3:
                stat, p_value = shapiro(data['Log_Returns'])
                if p_value > 0.05:
                    normal_stocks_tickers.append(ticker)
                    stock_data[ticker] = data
    except Exception as e:
        pass

print(f"âœ… Se encontraron {len(normal_stocks_tickers)} acciones cuyos rendimientos siguen una distribuciÃ³n normal.")

# ==============================================================================
# 4. SimulaciÃ³n, CÃ¡lculo de Precio Esperado y Probabilidades
# ==============================================================================
num_simulations = 100000
time_horizon = 10  # DÃ­as de trading
results = []

print("\nEjecutando simulaciones de Montecarlo...")

for ticker in normal_stocks_tickers:
    data = stock_data[ticker]
    if data.empty:
        continue

    mu = data['Log_Returns'].mean()
    sigma = data['Log_Returns'].std()
    last_price = data['Close'].iloc[-1]

    # Ejecutamos la simulaciÃ³n
    final_prices = np.zeros(num_simulations)
    for i in range(num_simulations):
        daily_returns = np.exp(mu - 0.5 * sigma**2 + sigma * np.random.normal(0, 1, time_horizon))
        final_price = last_price * np.prod(daily_returns)
        final_prices[i] = final_price

    # Calculamos mÃ©tricas
    expected_price = np.mean(final_prices)
    percentage_change = ((expected_price - last_price) / last_price) * 100

    # Calculamos las probabilidades
    increase_threshold = last_price * 1.01 # Umbral para incremento del 1%
    decrease_threshold = last_price * 0.99 # Umbral para decremento del 1%

    increase_threshold_value = increase_threshold.iloc[0]
    decrease_threshold_value = decrease_threshold.iloc[0]

    prob_increase = np.sum(final_prices >= increase_threshold_value) / num_simulations * 100
    prob_decrease = np.sum(final_prices <= decrease_threshold_value) / num_simulations * 100

    #prob_increase = np.sum(final_prices >= threshold_value) / num_simulations * 100
    #prob_increase = np.sum(final_prices >= increase_threshold)
    #print(prob_increase)
     #/ num_simulations * 100
    #prob_decrease = np.sum(final_prices <= decrease_threshold) / num_simulations * 100

    results.append({
        'Ticker': ticker,
        'Precio Actual (USD)': float(last_price),
        'Precio Esperado (USD)': float(expected_price),
        'Cambio Esperado (%)': float(percentage_change),
        'Prob. > +1%': float(prob_increase),
        'Prob. < -1%': float(prob_decrease)
    })

# ==============================================================================
# 5. Resultados: Tabla General
# ==============================================================================
if results:
    results_df = pd.DataFrame(results)
    sorted_results = results_df.sort_values(by='Cambio Esperado (%)', ascending=False)

    # Formateamos los nÃºmeros para una mejor visualizaciÃ³n
    sorted_results['Precio Actual (USD)'] = sorted_results['Precio Actual (USD)'].map('${:,.2f}'.format)
    sorted_results['Precio Esperado (USD)'] = sorted_results['Precio Esperado (USD)'].map('${:,.2f}'.format)
    sorted_results['Cambio Esperado (%)'] = sorted_results['Cambio Esperado (%)'].map('{:+.2f}%'.format)
    sorted_results['Prob. > +1%'] = sorted_results['Prob. > +1%'].map('{:.2f}%'.format)
    sorted_results['Prob. < -1%'] = sorted_results['Prob. < -1%'].map('{:.2f}%'.format)

    print("\n\nðŸ“ˆ TABLA DE RESULTADOS DE SIMULACIÃ“N (ORDENADA POR CAMBIO ESPERADO) ðŸ“ˆ\n")
    pd.set_option('display.max_rows', None)
    print(sorted_results.to_string(index=False))
else:
    print("\nNo se encontraron acciones que pasaran la prueba de normalidad.")


# ==============================================================================
# 6. Resultados: GrÃ¡ficos y Detalles Individuales
# ==============================================================================
if results:
    print("\n\nðŸ“Š ANÃLISIS GRÃFICO INDIVIDUAL ðŸ“Š\n")
    plt.style.use('seaborn-v0_8-darkgrid')

    # Usamos el dataframe sin formatear para los cÃ¡lculos de los grÃ¡ficos
    for index, row in results_df.iterrows():
        ticker = row['Ticker']
        data = stock_data[ticker]
        last_price = row['Precio Actual (USD)']
        expected_price = row['Precio Esperado (USD)']

        print(f"--- AnÃ¡lisis para {ticker} ---")
        print(f"Precio Actual: ${last_price:,.2f}")
        print(f"Precio Esperado en 1 Mes: ${expected_price:,.2f}")
        print(f"Cambio Esperado: {row['Cambio Esperado (%)']:+.2f}%")
        print(f"Probabilidad de un aumento > 1%: {row['Prob. > +1%']:.2f}%")
        print(f"Probabilidad de una disminuciÃ³n > 1%: {row['Prob. < -1%']:.2f}%\n")

        # VisualizaciÃ³n con una simulaciÃ³n mÃ¡s pequeÃ±a
        plt.figure(figsize=(10, 6))
        simulation_matrix = np.zeros((time_horizon + 1, 100)) # Matriz para 100 trayectorias
        simulation_matrix[0, :] = last_price

        mu = data['Log_Returns'].mean()
        sigma = data['Log_Returns'].std()

        for i in range(100):
            price_path = np.zeros(time_horizon + 1)
            price_path[0] = last_price
            for t in range(1, time_horizon + 1):
                daily_return = np.exp(mu - 0.5 * sigma**2 + sigma * np.random.normal(0, 1))
                price_path[t] = price_path[t-1] * daily_return
            simulation_matrix[:, i] = price_path

        plt.plot(simulation_matrix, color='gray', alpha=0.1)
        plt.plot(simulation_matrix.mean(axis=1), color='dodgerblue', linewidth=2, label='Trayectoria Promedio')
        plt.axhline(y=expected_price, color='red', linestyle='--', label=f'Precio Esperado Final: ${expected_price:.2f}')
        plt.title(f'SimulaciÃ³n de Precio para {ticker} (1 Mes)')
        plt.xlabel('DÃ­as de Trading Futuros')
        plt.ylabel('Precio de la AcciÃ³n (USD)')
        plt.legend()
        plt.show()
        print("\n" + "="*50 + "\n")

"""## 30 days"""

# -*- coding: utf-8 -*-
"""AnÃ¡lisis y SimulaciÃ³n de Acciones del S&P 500 con GrÃ¡ficos y Probabilidades.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_v_m5P5e7s_g_z_qC9bC3n9J8XwYtL4K
"""

# ==============================================================================
# 1. InstalaciÃ³n de LibrerÃ­as
# ==============================================================================
!pip install yfinance pandas numpy scipy matplotlib -q

import pandas as pd
import yfinance as yf
import numpy as np
from datetime import datetime, timedelta
from scipy.stats import shapiro
import matplotlib.pyplot as plt
import warnings

# Ignorar advertencias futuras para una salida mÃ¡s limpia
warnings.simplefilter(action='ignore', category=FutureWarning)

# ==============================================================================
# 2. ObtenciÃ³n de Tickers del S&P 500
# ==============================================================================
try:
    # Obtenemos la tabla de Wikipedia con los tickers del S&P 500
    url = 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'
    tabla = pd.read_html(url)
    sp500_tickers = tabla[0]['Symbol'].tolist()
    print(f"âœ… Se obtuvieron {len(sp500_tickers)} tickers del S&P 500.")
except Exception as e:
    print(f"âš ï¸ No se pudo obtener la lista de tickers: {e}")
    # Lista de respaldo en caso de fallo
    sp500_tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'TSLA', 'JPM', 'JNJ', 'V', 'PG']

# ==============================================================================
# 3. Descarga de Datos y Prueba de Normalidad
# ==============================================================================
end_date = datetime.now()
start_date = end_date - timedelta(days=365)
normal_stocks_tickers = []
stock_data = {}

print("\nDescargando datos y filtrando por distribuciÃ³n normal...")
for ticker in sp500_tickers:
    try:
        # Algunos tickers en la lista de Wikipedia pueden ser incorrectos (ej. 'BF.B'),
        # yfinance puede necesitar un ajuste ('BF-B'). yfinance a menudo maneja esto,
        # pero el manejo de excepciones es clave.
        data = yf.download(ticker, start=start_date, end=end_date, progress=False, auto_adjust=True)
        if not data.empty and len(data) > 30:
            data['Log_Returns'] = np.log(data['Close'] / data['Close'].shift(1))
            data.dropna(inplace=True)
            if len(data['Log_Returns']) > 3:
                stat, p_value = shapiro(data['Log_Returns'])
                if p_value > 0.05:
                    normal_stocks_tickers.append(ticker)
                    stock_data[ticker] = data
    except Exception as e:
        pass

print(f"âœ… Se encontraron {len(normal_stocks_tickers)} acciones cuyos rendimientos siguen una distribuciÃ³n normal.")

# ==============================================================================
# 4. SimulaciÃ³n, CÃ¡lculo de Precio Esperado y Probabilidades
# ==============================================================================
num_simulations = 100000
time_horizon = 21  # DÃ­as de trading
results = []

print("\nEjecutando simulaciones de Montecarlo...")

for ticker in normal_stocks_tickers:
    data = stock_data[ticker]
    if data.empty:
        continue

    mu = data['Log_Returns'].mean()
    sigma = data['Log_Returns'].std()
    last_price = data['Close'].iloc[-1]

    # Ejecutamos la simulaciÃ³n
    final_prices = np.zeros(num_simulations)
    for i in range(num_simulations):
        daily_returns = np.exp(mu - 0.5 * sigma**2 + sigma * np.random.normal(0, 1, time_horizon))
        final_price = last_price * np.prod(daily_returns)
        final_prices[i] = final_price

    # Calculamos mÃ©tricas
    expected_price = np.mean(final_prices)
    percentage_change = ((expected_price - last_price) / last_price) * 100

    # Calculamos las probabilidades
    increase_threshold = last_price * 1.01 # Umbral para incremento del 1%
    decrease_threshold = last_price * 0.99 # Umbral para decremento del 1%

    increase_threshold_value = increase_threshold.iloc[0]
    decrease_threshold_value = decrease_threshold.iloc[0]

    prob_increase = np.sum(final_prices >= increase_threshold_value) / num_simulations * 100
    prob_decrease = np.sum(final_prices <= decrease_threshold_value) / num_simulations * 100

    #prob_increase = np.sum(final_prices >= threshold_value) / num_simulations * 100
    #prob_increase = np.sum(final_prices >= increase_threshold)
    #print(prob_increase)
     #/ num_simulations * 100
    #prob_decrease = np.sum(final_prices <= decrease_threshold) / num_simulations * 100

    results.append({
        'Ticker': ticker,
        'Precio Actual (USD)': float(last_price),
        'Precio Esperado (USD)': float(expected_price),
        'Cambio Esperado (%)': float(percentage_change),
        'Prob. > +1%': float(prob_increase),
        'Prob. < -1%': float(prob_decrease)
    })

# ==============================================================================
# 5. Resultados: Tabla General
# ==============================================================================
if results:
    results_df = pd.DataFrame(results)
    sorted_results = results_df.sort_values(by='Cambio Esperado (%)', ascending=False)

    # Formateamos los nÃºmeros para una mejor visualizaciÃ³n
    sorted_results['Precio Actual (USD)'] = sorted_results['Precio Actual (USD)'].map('${:,.2f}'.format)
    sorted_results['Precio Esperado (USD)'] = sorted_results['Precio Esperado (USD)'].map('${:,.2f}'.format)
    sorted_results['Cambio Esperado (%)'] = sorted_results['Cambio Esperado (%)'].map('{:+.2f}%'.format)
    sorted_results['Prob. > +1%'] = sorted_results['Prob. > +1%'].map('{:.2f}%'.format)
    sorted_results['Prob. < -1%'] = sorted_results['Prob. < -1%'].map('{:.2f}%'.format)

    print("\n\nðŸ“ˆ TABLA DE RESULTADOS DE SIMULACIÃ“N (ORDENADA POR CAMBIO ESPERADO) ðŸ“ˆ\n")
    pd.set_option('display.max_rows', None)
    print(sorted_results.to_string(index=False))
else:
    print("\nNo se encontraron acciones que pasaran la prueba de normalidad.")


# ==============================================================================
# 6. Resultados: GrÃ¡ficos y Detalles Individuales
# ==============================================================================
if results:
    print("\n\nðŸ“Š ANÃLISIS GRÃFICO INDIVIDUAL ðŸ“Š\n")
    plt.style.use('seaborn-v0_8-darkgrid')

    # Usamos el dataframe sin formatear para los cÃ¡lculos de los grÃ¡ficos
    for index, row in results_df.iterrows():
        ticker = row['Ticker']
        data = stock_data[ticker]
        last_price = row['Precio Actual (USD)']
        expected_price = row['Precio Esperado (USD)']

        print(f"--- AnÃ¡lisis para {ticker} ---")
        print(f"Precio Actual: ${last_price:,.2f}")
        print(f"Precio Esperado en 1 Mes: ${expected_price:,.2f}")
        print(f"Cambio Esperado: {row['Cambio Esperado (%)']:+.2f}%")
        print(f"Probabilidad de un aumento > 1%: {row['Prob. > +1%']:.2f}%")
        print(f"Probabilidad de una disminuciÃ³n > 1%: {row['Prob. < -1%']:.2f}%\n")

        # VisualizaciÃ³n con una simulaciÃ³n mÃ¡s pequeÃ±a
        plt.figure(figsize=(10, 6))
        simulation_matrix = np.zeros((time_horizon + 1, 100)) # Matriz para 100 trayectorias
        simulation_matrix[0, :] = last_price

        mu = data['Log_Returns'].mean()
        sigma = data['Log_Returns'].std()

        for i in range(100):
            price_path = np.zeros(time_horizon + 1)
            price_path[0] = last_price
            for t in range(1, time_horizon + 1):
                daily_return = np.exp(mu - 0.5 * sigma**2 + sigma * np.random.normal(0, 1))
                price_path[t] = price_path[t-1] * daily_return
            simulation_matrix[:, i] = price_path

        plt.plot(simulation_matrix, color='gray', alpha=0.1)
        plt.plot(simulation_matrix.mean(axis=1), color='dodgerblue', linewidth=2, label='Trayectoria Promedio')
        plt.axhline(y=expected_price, color='red', linestyle='--', label=f'Precio Esperado Final: ${expected_price:.2f}')
        plt.title(f'SimulaciÃ³n de Precio para {ticker} (1 Mes)')
        plt.xlabel('DÃ­as de Trading Futuros')
        plt.ylabel('Precio de la AcciÃ³n (USD)')
        plt.legend()
        plt.show()
        print("\n" + "="*50 + "\n")